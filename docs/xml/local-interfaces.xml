<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC 
    "-//Dawid Weiss//DTD DocBook V3.1-Based Extension for XML and graphics inclusion//EN" 
    "http://www.cs.put.poznan.pl/dweiss/dtd/dweiss-docbook-extensions.dtd" [

<!ENTITY % isopub SYSTEM "iso-pub.ent"> 
%isopub; 
<!ENTITY % local SYSTEM "local-entities.ent"> 
%local; 

]>
<chapter>
    <title>Local Data Exchange in the &carrot; Framework &mdash; Design document assumptions and concepts</title>

    <section>
    	<title>Introduction</title>
    	
    	<section>
    		<title>What are local interfaces?</title>
    		
    		<para>
            Under the term local interfaces 
            stands a very general concept which we will use in this document to refer to any method of
            combining &carrot; components that does not involve intermediate data transfers
            via pipes, sockets or the network. 
            </para>
            <para>
            Local interfaces can therefore be usually associated, or identify
            direct method calls from one component to another (from one Java
            method to another).
    		</para>
    	</section>
        
        <section>
            <title>Why local interfaces when we have the remote ones?</title>
            
            <para>
            Currently used XML/HTTP pipeline was designed for flexibility, but lacks
            efficiency. Local interfaces should yield a performance improvement that would
            allow use of Carrot2 in production environment (and not only for
            research).
            </para>

            <para>
            Local interfaces allow embedding Carrot2 components and controller into other
            applications, not necessarily networked, or servlet-container based.
            </para>
        </section>

    </section>
    
    <section>
        <title>Design goals and constraints</title>

        <para>
        Ideally, the new design should fulfill the following:
        </para>
        
        <itemizedlist>
            <listitem>
            <para>Performance</para>
            <orderedlist continuation="restarts">
                <listitem id="a.1" xreflabel="Local method calls"><para>local method calls</para></listitem>
                <listitem id="a.2" xreflabel="Memory/ object reuse"><para>memory/ object reuse</para></listitem>
                <listitem id="a.3" xreflabel="Direct typing"><para>direct typing (no interfaces)</para></listitem>
                <listitem id="a.4" xreflabel="Single-threaded pipelines"><para>single-threaded process pipeline</para></listitem>
	            <listitem id="a.5" xreflabel="Processes in compiled code"><para>processes written in compiled code</para></listitem>
            </orderedlist>
            </listitem>

            <listitem>
            <para>Scalability</para>
            <orderedlist continuation="continues">
                <listitem id="b.1" xreflabel="Component-language independence"><para>Component-language independence.</para></listitem>
                <listitem id="b.2" xreflabel="Incremental pipelines"><para>Incremental pipeline (partial processing).</para></listitem>
                <listitem id="b.3" xreflabel="Distributed processing"><para>Distributed processing.</para></listitem>
            </orderedlist>
            </listitem>
            
            <listitem>
            <para>Flexibility (openness)</para>
            <orderedlist continuation="continues">
                <listitem id="c.1" xreflabel="Flexible data types"><para>The design must not restrict or limit the data types
                       passed between components (i.e. components may push in the
                       pipeline whatever they want to).</para></listitem>
                <listitem id="c.2" xreflabel="Code reuse"><para>Reuse of components and common code.</para></listitem>
            </orderedlist>
            </listitem>
            
            <listitem>
                <para>User-friendly design</para>
                <orderedlist continuation="continues">
                <listitem id="d.1" xreflabel="Component compatibility verification"><para>Controller handles some of the complexity of process verification
                       (incompatible components linked in a chain).</para></listitem>
                <listitem id="d.2" xreflabel="Scripted components and processes"><para>Components and processes easily scripted without code recompilation.</para></listitem>
                </orderedlist>
            </listitem>
        </itemizedlist>

        <para>
            Many of the above goals are contradictory &mdash; for example, (<xref linkend="b.1" />) and (<xref linkend="a.3" />), or
            (<xref linkend="a.5" />) and (<xref linkend="d.2" />). The proposed design emphasizes performance, but also attempts
            to preserve these aspects of flexibility that we thought were most valuable in
            the framework. From the above set of goals we have selected the following as
            driving factors for the new design:
        </para>

        <itemizedlist>
            <listitem>
                <para><xref linkend="a.1"/></para>
                <para>
                Local method calls are the key to achieving high performance. Data must not
                be passed via bounded buffers, but directly from component to component. If
                at all possible, data should be reused and not copied/ duplicated. 
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="a.2"/></para>
                <para>
                Intense memory allocation/ garbage collection slows down any Java application
                by a factor of magnitude. The design must provide means to reuse intermediate
                component data from request to request. 
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="a.4"/></para>
                <para>
                It seems that the cost of interprocess (or inter-thread) communication
                and synchronization is usually higher than the gain from parallelization.
                One request should be processed by one thread entirely. 
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="a.5"/></para>
                <para>
                Currently processes are BeanShell scripts. While there have been some motions
                for BeanShell to provide bytecode compiler, the new design should allow
                specifying processes in an already precompiled form.
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="b.2"/></para>
                <para>
                Components may not need all of their successors' data. Passing a single <quote>results</quote> object
                sequentially from component to component would be memory-inefficient.
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="c.1"/></para>
                <para>
                This is the most difficult issue: how to specify local binding interfaces without
                knowing in advance what types of data can be passed between components.
                We think the proposed design handles this issue gracefully and at the same time
                allows efficient implementations (see TODO).
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="c.2"/></para>
                <para>
                Components will share a common memory space, so common code sharing
                should not be a problem (unlike Web applications, which were constrained by
                sandboxed class loaders). Reusing code limits application's memory footprint
                and in effect the impact of swapping memory by the operating system.
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="d.2"/></para>
                <para>
                BeanShell 2.0-series will be used as an alternative form of providing process
                definitions (because it allows subclassing and anonymous interface
                implementations).
                </para>
            </listitem>
        </itemizedlist>

        <para>
        The goals that we consider of lesser importance (or thrown away because of conflicts):
        </para>

        <itemizedlist>
            <listitem>
                <para><xref linkend="a.3"/></para>
                <para>
    Type-checks at runtime are quite costly, but we will use interfaces anyway, because
    they provide more flexibility in designing the controller.
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="b.1"/></para>
                <para>
    Similarily to (<xref linkend="a.4"/>): we think that distributing entire atomic single-threaded
    local processes will be more efficient than distributing components. 
    If really needed, local stubs can simulate local interfaces for remote components.
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="b.3"/></para>
                <para>
    Can be achieved by using JNI wrappers. This requires more effort, but will work.
                </para>
            </listitem>
            <listitem>
                <para><xref linkend="d.1"/></para>
                <para>
    This is a very nice feature to have, but it is in conflict with (<xref linkend="c.1"/>) and there
    seems to be no elegant way to fulfill this goal. We propose a method of component
    compatibility verification based on explicit capabilities (declared inside
    a component), but we do not make these capabilities an obligation for
    component/ process designers.
                </para>
            </listitem>
        </itemizedlist>
    </section>
    
    <section>
        <title>Overview of the proposed design</title>

        <para>
        The proposed design follows the framework's architecture for remote components, but
        removes the need of data serialization and provides possibilities of components directly
        invoking each other's methods.
        </para>
        
        <section>
            <title>Components</title>
            
<para>
A class diagram of the core classes in the local architecture is presented in
<xref linkend="figure:fig.1"/>.
</para>

<pasteFigure id="fig.1" src="core-local-classes.png" width="10cm">Class diagram of the core classes in the local architecture</pasteFigure>
            
<para>
All components must implement <interfacename>LocalComponent</interfacename> interface. 
This interface contains
methods that allow component initialization at the moment of creation,
verification of compatibility with other components and finally, 
lifecycle methods that allow the component to be reused by a component container.  
</para>

<para>
 The <interfacename>LocalComponent</interfacename> interface is the super interface for all three types
 of local components:
</para>

<itemizedlist spacing="compact">
    <listitem><para><interfacename>LocalInputComponent</interfacename> &mdash;
    components accepting user queries and producing initial data.</para></listitem>
    <listitem><para><interfacename>LocalFilterComponent</interfacename> &mdash;
    components that somehow alter or enrich the data.
    </para></listitem>
    <listitem><para><interfacename>LocalOutputComponent</interfacename> &mdash;
    components gathering the result or doing something with the result.
    For example, a visual component displaying the data can implement this interface.
    </para></listitem>
</itemizedlist>

<para>
Lifecycle of a component is regulated by a contract in <interfacename>LocalComponent</interfacename>
interface. A state diagram for a lifecycle of a component is presented in
<xref linkend="figure:fig.statechart" />. Transitions in the diagram represent callback method calls from
a process object (an instance of <interfacename>LocalProcess</interfacename>
interface). All method names and the specifics of the contract are explained
in JavaDoc documentation and are omitted here. 
</para>

<pasteFigure src="component-lifecycle.png" id="fig.statechart" width="10cm"
>State diagram of a lifecycle of a local component</pasteFigure>

<para>
This base functionality of a component is slightly extended depending on the role of a
component in a processing chain; input/ filter and output components are distinguished. Input
components take an additional <literal>query</literal> argument, output components 
provide a method for harvesting the result of a process. Filter and input components also 
specify a very important method <methodname>setNext()</methodname> 
that lets the local process to combine components in a processing chain and thus allow components
to interact directly with each other.
</para>

<para>
The above interfaces are stripped of any functional (data-related) methods because they
relate to the area of concern of the local component container and the governing process. 
Methods specific to data processing should be provided by component designers as an
extension to the base interfaces.
Components must ensure at the time of linking in a processing chain that they can <quote>understand</quote>
the successor's data-related methods, usually by attemting to cast it to a more specific type.
</para> 
        </section>
        
        <section>
            <title>Component initialization</title>
            <para>
            Before any processing begins, components and processes are added to a
            component container, also referred to as a controller component.
            The controller is not explicitly specified in the core framework,
            because it is mostly application-dependent and beyond the scope of
            the specification. However, a <interfacename>LocalControllerContext</interfacename> interface
            is specified and passed to each
            instantiated component. <interfacename>LocalControllerContext</interfacename> lets
            components and processes to verify compatibility with each other and provide some
            insight into the availability of other component types.
            </para>
        </section>
        
        <section>
            <title>Processes</title>

            <para>
            A local process embodies the logic needed to process queries and assemble
            componenents in a processing chain.
            Instances of this interface must be written by the user of the framework,
            because it is the process that decides which components are used to process
            a query in how they are connected to each other. The contract on
            the behavior of a <interfacename>LocalProcess</interfacename> instances
            is quite complex and developers are encouraged to subclass
            the reference implementation of <classname>LocalProcessBase</classname> and
            override the hook methods specified in there. Having said that, implementing
            the raw interface gives full control over the component assembly and query
            execution process.
            </para>
            <para>
            See JavaDoc for up-to-date information about the details of 
            <interfacename>LocalProcess</interfacename> implementation.
            </para>
        </section>
        
        <section>
            <title>Query execution</title>

        <para>
When all processes and components are added to a controller, it is ready to
process requests. The controller passes a query request to a local process 
instance for execution using the <methodname>query()</methodname> method:
        </para>

        <screen>public void Object query(RequestContext context, String query)
    throws Exception;</screen>

    <para>
A process can now request instances of components (this allows pooling of
component instances per-request and ensures they are always returned to the
pool), link them in a processing chain and perform the request processing.
    </para>

    <para>
The contract on the <methodname>query()</methodname> method is detailed
in the JavaDoc documentation.
    </para>   

    <para>
    This local data exchange design lacks the 'monitoring' aspect of the http/xml solution, where the
    data stream was proxied through the controller. Here, once the <methodname>startProcessing()</methodname>
    method is invoked on the first component in the chain, the method calls (data-related and enforced by
    the contract) are pretty much out of controll of the process object.
    However, direct chained method calls
    speed up processing, because data can be passed directly between components.
    </para>

        </section>

    </section>

</chapter>
